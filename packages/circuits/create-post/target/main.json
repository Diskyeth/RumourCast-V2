{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":6830764402488986365,"abi":{"parameters":[{"name":"address","type":{"kind":"field"},"visibility":"private"},{"name":"balance","type":{"kind":"field"},"visibility":"private"},{"name":"note_root","type":{"kind":"field"},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"note_hash_path","type":{"kind":"array","length":13,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"message_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"text","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"public"},{"name":"embed_1","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"public"},{"name":"embed_2","type":{"kind":"array","length":16,"type":{"kind":"field"}},"visibility":"public"},{"name":"quote_hash","type":{"kind":"field"},"visibility":"public"},{"name":"channel","type":{"kind":"field"},"visibility":"public"},{"name":"parent_hash","type":{"kind":"field"},"visibility":"public"},{"name":"reveal_hash","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":64},{"kind":"array","length":16,"type":{"kind":"field"}},{"kind":"array","length":16,"type":{"kind":"field"}},{"kind":"array","length":16,"type":{"kind":"field"}},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"field"},{"kind":"array","length":2,"type":{"kind":"field"}}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::collections::vec::Vec;\nuse crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n    let mut block_bytes = [0; BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let max_blocks_length = (BLOCK_SIZE_IN_BYTES * max_blocks);\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let num_limbs = max_blocks_length / WORD_SIZE;\n    let mut sliced_buffer = Vec::new();\n    for i in 0..num_limbs {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer.push(sliced as u64);\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer.get(j);\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer.get(i * LIMBS_PER_BLOCK + j);\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer.get(j);\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer.get(i * LIMBS_PER_BLOCK + j);\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        // \"hello world\"\n        let input = [72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33];\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\n//\n// Uncommenting this results in deprecated warnings in the stdlib\n// #[deprecated]\nfn mimc<let N: u32>(x: Field, k: Field, constants: [Field; N], exp: Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1..constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    }\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS: u32 = 91;\n//generated from seed \"mimc\" using keccak256\nglobal MIMC_BN254_CONSTANTS: [Field; MIMC_BN254_ROUNDS] = [\n    0,\n    20888961410941983456478427210666206549300505294776164667214940546594746570981,\n    15265126113435022738560151911929040668591755459209400716467504685752745317193,\n    8334177627492981984476504167502758309043212251641796197711684499645635709656,\n    1374324219480165500871639364801692115397519265181803854177629327624133579404,\n    11442588683664344394633565859260176446561886575962616332903193988751292992472,\n    2558901189096558760448896669327086721003508630712968559048179091037845349145,\n    11189978595292752354820141775598510151189959177917284797737745690127318076389,\n    3262966573163560839685415914157855077211340576201936620532175028036746741754,\n    17029914891543225301403832095880481731551830725367286980611178737703889171730,\n    4614037031668406927330683909387957156531244689520944789503628527855167665518,\n    19647356996769918391113967168615123299113119185942498194367262335168397100658,\n    5040699236106090655289931820723926657076483236860546282406111821875672148900,\n    2632385916954580941368956176626336146806721642583847728103570779270161510514,\n    17691411851977575435597871505860208507285462834710151833948561098560743654671,\n    11482807709115676646560379017491661435505951727793345550942389701970904563183,\n    8360838254132998143349158726141014535383109403565779450210746881879715734773,\n    12663821244032248511491386323242575231591777785787269938928497649288048289525,\n    3067001377342968891237590775929219083706800062321980129409398033259904188058,\n    8536471869378957766675292398190944925664113548202769136103887479787957959589,\n    19825444354178182240559170937204690272111734703605805530888940813160705385792,\n    16703465144013840124940690347975638755097486902749048533167980887413919317592,\n    13061236261277650370863439564453267964462486225679643020432589226741411380501,\n    10864774797625152707517901967943775867717907803542223029967000416969007792571,\n    10035653564014594269791753415727486340557376923045841607746250017541686319774,\n    3446968588058668564420958894889124905706353937375068998436129414772610003289,\n    4653317306466493184743870159523234588955994456998076243468148492375236846006,\n    8486711143589723036499933521576871883500223198263343024003617825616410932026,\n    250710584458582618659378487568129931785810765264752039738223488321597070280,\n    2104159799604932521291371026105311735948154964200596636974609406977292675173,\n    16313562605837709339799839901240652934758303521543693857533755376563489378839,\n    6032365105133504724925793806318578936233045029919447519826248813478479197288,\n    14025118133847866722315446277964222215118620050302054655768867040006542798474,\n    7400123822125662712777833064081316757896757785777291653271747396958201309118,\n    1744432620323851751204287974553233986555641872755053103823939564833813704825,\n    8316378125659383262515151597439205374263247719876250938893842106722210729522,\n    6739722627047123650704294650168547689199576889424317598327664349670094847386,\n    21211457866117465531949733809706514799713333930924902519246949506964470524162,\n    13718112532745211817410303291774369209520657938741992779396229864894885156527,\n    5264534817993325015357427094323255342713527811596856940387954546330728068658,\n    18884137497114307927425084003812022333609937761793387700010402412840002189451,\n    5148596049900083984813839872929010525572543381981952060869301611018636120248,\n    19799686398774806587970184652860783461860993790013219899147141137827718662674,\n    19240878651604412704364448729659032944342952609050243268894572835672205984837,\n    10546185249390392695582524554167530669949955276893453512788278945742408153192,\n    5507959600969845538113649209272736011390582494851145043668969080335346810411,\n    18177751737739153338153217698774510185696788019377850245260475034576050820091,\n    19603444733183990109492724100282114612026332366576932662794133334264283907557,\n    10548274686824425401349248282213580046351514091431715597441736281987273193140,\n    1823201861560942974198127384034483127920205835821334101215923769688644479957,\n    11867589662193422187545516240823411225342068709600734253659804646934346124945,\n    18718569356736340558616379408444812528964066420519677106145092918482774343613,\n    10530777752259630125564678480897857853807637120039176813174150229243735996839,\n    20486583726592018813337145844457018474256372770211860618687961310422228379031,\n    12690713110714036569415168795200156516217175005650145422920562694422306200486,\n    17386427286863519095301372413760745749282643730629659997153085139065756667205,\n    2216432659854733047132347621569505613620980842043977268828076165669557467682,\n    6309765381643925252238633914530877025934201680691496500372265330505506717193,\n    20806323192073945401862788605803131761175139076694468214027227878952047793390,\n    4037040458505567977365391535756875199663510397600316887746139396052445718861,\n    19948974083684238245321361840704327952464170097132407924861169241740046562673,\n    845322671528508199439318170916419179535949348988022948153107378280175750024,\n    16222384601744433420585982239113457177459602187868460608565289920306145389382,\n    10232118865851112229330353999139005145127746617219324244541194256766741433339,\n    6699067738555349409504843460654299019000594109597429103342076743347235369120,\n    6220784880752427143725783746407285094967584864656399181815603544365010379208,\n    6129250029437675212264306655559561251995722990149771051304736001195288083309,\n    10773245783118750721454994239248013870822765715268323522295722350908043393604,\n    4490242021765793917495398271905043433053432245571325177153467194570741607167,\n    19596995117319480189066041930051006586888908165330319666010398892494684778526,\n    837850695495734270707668553360118467905109360511302468085569220634750561083,\n    11803922811376367215191737026157445294481406304781326649717082177394185903907,\n    10201298324909697255105265958780781450978049256931478989759448189112393506592,\n    13564695482314888817576351063608519127702411536552857463682060761575100923924,\n    9262808208636973454201420823766139682381973240743541030659775288508921362724,\n    173271062536305557219323722062711383294158572562695717740068656098441040230,\n    18120430890549410286417591505529104700901943324772175772035648111937818237369,\n    20484495168135072493552514219686101965206843697794133766912991150184337935627,\n    19155651295705203459475805213866664350848604323501251939850063308319753686505,\n    11971299749478202793661982361798418342615500543489781306376058267926437157297,\n    18285310723116790056148596536349375622245669010373674803854111592441823052978,\n    7069216248902547653615508023941692395371990416048967468982099270925308100727,\n    6465151453746412132599596984628739550147379072443683076388208843341824127379,\n    16143532858389170960690347742477978826830511669766530042104134302796355145785,\n    19362583304414853660976404410208489566967618125972377176980367224623492419647,\n    1702213613534733786921602839210290505213503664731919006932367875629005980493,\n    10781825404476535814285389902565833897646945212027592373510689209734812292327,\n    4212716923652881254737947578600828255798948993302968210248673545442808456151,\n    7594017890037021425366623750593200398174488805473151513558919864633711506220,\n    18979889247746272055963929241596362599320706910852082477600815822482192194401,\n    13602139229813231349386885113156901793661719180900395818909719758150455500533,\n];\n\n//mimc implementation with hardcoded parameters for BN254 curve.\n#[field(bn254)]\n#[deprecated]\npub fn mimc_bn254<let N: u32>(array: [Field; N]) -> Field {\n    let exponent = 7;\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, MIMC_BN254_CONSTANTS, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n\npub struct MimcHasher {\n    _state: [Field],\n}\n\nimpl Hasher for MimcHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let exponent = 7;\n        let mut r = 0;\n        for i in 0..self._state.len() {\n            let h = mimc(self._state[i], r, MIMC_BN254_CONSTANTS, exponent);\n            r = r + self._state[i] + h;\n        }\n        r\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for MimcHasher {\n    fn default() -> Self {\n        MimcHasher { _state: &[] }\n    }\n}\n","path":"std/hash/mimc.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"39":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"70":{"source":"use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    // Token Balance\n    address: Field,\n    balance: Field,\n    // Merkle Membership\n    note_root: pub Field,\n    index: Field,\n    note_hash_path: [Field; 13],\n    // Signature\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    // Token Data\n    token_address: pub Field,\n    timestamp: pub u64,\n    // Post\n    text: pub [Field; 16],\n    embed_1: pub [Field; 16],\n    embed_2: pub [Field; 16],\n    quote_hash: pub Field,\n    channel: pub Field,\n    parent_hash: pub Field,\n    reveal_hash: pub [Field; 2],\n) -> pub (u64, [Field; 16], [Field; 16], [Field; 16], Field, Field, Field, Field, [Field; 2]) {\n    let recovered_address = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, message_hash);\n    assert(address == recovered_address);\n\n    let commitment = std::hash::mimc::mimc_bn254([address, balance]);\n\n    // Check that the input note commitment is in the root\n    let new_root = std::merkle::compute_merkle_root(commitment, index, note_hash_path);\n    assert(new_root == note_root);\n\n    (\n        timestamp, text, embed_1, embed_2, quote_hash, channel, parent_hash, token_address,\n        reveal_hash,\n    )\n}\n","path":"/Users/kartik/2024/anon/packages/circuits/create-post/src/main.nr"},"71":{"source":"use dep::std;\n \nmod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/kartik/nargo/github.com/signorecello/ecrecover-noirmain/src/lib.nr"},"72":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/kartik/nargo/github.com/signorecello/ecrecover-noirmain/src/secp256k1.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}