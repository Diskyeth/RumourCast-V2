{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":16026386707479103557,"abi":{"parameters":[{"name":"address","type":{"kind":"field"},"visibility":"private"},{"name":"balance","type":{"kind":"field"},"visibility":"private"},{"name":"note_root","type":{"kind":"field"},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"note_hash_path","type":{"kind":"array","length":13,"type":{"kind":"field"}},"visibility":"private"},{"name":"signature","type":{"kind":"array","length":64,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"message_hash","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_x","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"pub_key_y","type":{"kind":"array","length":32,"type":{"kind":"integer","sign":"unsigned","width":8}},"visibility":"private"},{"name":"token_address","type":{"kind":"field"},"visibility":"public"},{"name":"timestamp","type":{"kind":"integer","sign":"unsigned","width":64},"visibility":"public"},{"name":"hash","type":{"kind":"field"},"visibility":"public"}],"return_type":{"abi_type":{"kind":"tuple","fields":[{"kind":"integer","sign":"unsigned","width":64},{"kind":"field"},{"kind":"field"}]},"visibility":"public"},"error_types":{}},"bytecode":"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","debug_symbols":"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","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"26":{"source":"pub mod bn254;\nuse bn254::lt as bn254_lt;\nuse crate::runtime::is_unconstrained;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        assert(BIT_SIZE < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(BIT_SIZE);\n    }\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_le_bits)]\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_le_bits\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n    /// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n    /// wrap around due to overflow when verifying the decomposition.\n    #[builtin(to_be_bits)]\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {}\n    // docs:end:to_be_bits\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    // docs:start:to_le_radix\n    pub fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_le_radix(radix)\n    }\n    // docs:end:to_le_radix\n\n    // docs:start:to_be_radix\n    pub fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            crate::assert_constant(radix);\n        }\n        self.__to_be_radix(radix)\n    }\n    // docs:end:to_be_radix\n\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix<let N: u32>(self, radix: u32) -> [u8; N] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..32 {\n        if (!done) {\n            let x_byte = x_bytes[32 - 1 - i] as u8;\n            let y_byte = y_bytes[32 - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nmod tests {\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_bytes();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_bytes();\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bits), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        let field = 2;\n        let bits: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bits, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bits), field);\n    }\n    // docs:end:to_le_radix_example\n}\n","path":"std/field/mod.nr"},"27":{"source":"use crate::collections::vec::Vec;\nuse crate::runtime::is_unconstrained;\n\nglobal BLOCK_SIZE_IN_BYTES: u32 = 136; //(1600 - BITS * 2) / WORD_SIZE;\nglobal WORD_SIZE: u32 = 8; // Limbs are made up of u64s so 8 bytes each.\nglobal LIMBS_PER_BLOCK: u32 = BLOCK_SIZE_IN_BYTES / WORD_SIZE;\nglobal NUM_KECCAK_LANES: u32 = 25;\n\n#[foreign(keccakf1600)]\nfn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n\n#[no_predicates]\npub(crate) fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32] {\n    assert(N >= message_size);\n    let mut block_bytes = [0; BLOCK_SIZE_IN_BYTES];\n    if is_unconstrained() {\n        for i in 0..message_size {\n            block_bytes[i] = input[i];\n        }\n    } else {\n        for i in 0..N {\n            if i < message_size {\n                block_bytes[i] = input[i];\n            }\n        }\n    }\n\n    //1. format_input_lanes\n    let max_blocks = (N + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    //maximum number of bytes to hash\n    let max_blocks_length = (BLOCK_SIZE_IN_BYTES * max_blocks);\n    let real_max_blocks = (message_size + BLOCK_SIZE_IN_BYTES) / BLOCK_SIZE_IN_BYTES;\n    let real_blocks_bytes = real_max_blocks * BLOCK_SIZE_IN_BYTES;\n\n    block_bytes[message_size] = 1;\n    block_bytes[real_blocks_bytes - 1] = 0x80;\n\n    // populate a vector of 64-bit limbs from our byte array\n    let num_limbs = max_blocks_length / WORD_SIZE;\n    let mut sliced_buffer = Vec::new();\n    for i in 0..num_limbs {\n        let limb_start = WORD_SIZE * i;\n\n        let mut sliced = 0;\n        let mut v = 1;\n        for k in 0..WORD_SIZE {\n            sliced += v * (block_bytes[limb_start + k] as Field);\n            v *= 256;\n        }\n\n        sliced_buffer.push(sliced as u64);\n    }\n\n    //2. sponge_absorb\n    let mut state: [u64; NUM_KECCAK_LANES] = [0; NUM_KECCAK_LANES];\n    // When in an unconstrained runtime we can take advantage of runtime loop bounds,\n    // thus allowing us to simplify the loop body.\n    if is_unconstrained() {\n        for i in 0..real_max_blocks {\n            if (i == 0) {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = sliced_buffer.get(j);\n                }\n            } else {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer.get(i * LIMBS_PER_BLOCK + j);\n                }\n            }\n            state = keccakf1600(state);\n        }\n    } else {\n        // `real_max_blocks` is guaranteed to at least be `1`\n        // We peel out the first block as to avoid a conditional inside of the loop.\n        // Otherwise, a dynamic predicate can cause a blowup in a constrained runtime.\n        for j in 0..LIMBS_PER_BLOCK {\n            state[j] = sliced_buffer.get(j);\n        }\n        state = keccakf1600(state);\n        for i in 1..max_blocks {\n            if i < real_max_blocks {\n                for j in 0..LIMBS_PER_BLOCK {\n                    state[j] = state[j] ^ sliced_buffer.get(i * LIMBS_PER_BLOCK + j);\n                }\n                state = keccakf1600(state);\n            }\n        }\n    }\n\n    //3. sponge_squeeze\n    let mut result = [0; 32];\n    for i in 0..4 {\n        let lane = state[i] as Field;\n        let lane_le: [u8; 8] = lane.to_le_bytes();\n        for j in 0..8 {\n            result[8 * i + j] = lane_le[j];\n        }\n    }\n    result\n}\n\nmod tests {\n    use super::keccak256;\n\n    #[test]\n    fn smoke_test() {\n        let input = [0xbd];\n        let result = [\n            0x5a, 0x50, 0x2f, 0x9f, 0xca, 0x46, 0x7b, 0x26, 0x6d, 0x5b, 0x78, 0x33, 0x65, 0x19,\n            0x37, 0xe8, 0x05, 0x27, 0x0c, 0xa3, 0xf3, 0xaf, 0x1c, 0x0d, 0xd2, 0x46, 0x2d, 0xca,\n            0x4b, 0x3b, 0x1a, 0xbf,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn hash_hello_world() {\n        // \"hello world\"\n        let input = [72, 101, 108, 108, 111, 32, 119, 111, 114, 108, 100, 33];\n        let result = [\n            0xec, 0xd0, 0xe1, 0x8, 0xa9, 0x8e, 0x19, 0x2a, 0xf1, 0xd2, 0xc2, 0x50, 0x55, 0xf4, 0xe3,\n            0xbe, 0xd7, 0x84, 0xb5, 0xc8, 0x77, 0x20, 0x4e, 0x73, 0x21, 0x9a, 0x52, 0x3, 0x25, 0x1f,\n            0xea, 0xab,\n        ];\n        assert_eq(keccak256(input, input.len()), result);\n    }\n\n    #[test]\n    fn var_size_hash() {\n        let input = [\n            189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205,\n            206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222,\n            223,\n        ];\n        let result = [\n            226, 37, 115, 94, 94, 196, 72, 116, 194, 105, 79, 233, 65, 12, 30, 94, 181, 131, 170,\n            219, 171, 166, 236, 88, 143, 67, 255, 160, 248, 214, 39, 129,\n        ];\n        assert_eq(keccak256(input, 13), result);\n    }\n}\n","path":"std/hash/keccak.nr"},"28":{"source":"use crate::hash::Hasher;\nuse crate::default::Default;\n\n// mimc-p/p implementation\n// constants are (publicly generated) random numbers, for instance using keccak as a ROM.\n// You must use constants generated for the native field\n// Rounds number should be ~ log(p)/log(exp)\n// For 254 bit primes, exponent 7 and 91 rounds seems to be recommended\n//\n// Uncommenting this results in deprecated warnings in the stdlib\n// #[deprecated]\nfn mimc<let N: u32>(x: Field, k: Field, constants: [Field; N], exp: Field) -> Field {\n    //round 0\n    let mut t = x + k;\n    let mut h = t.pow_32(exp);\n    //next rounds\n    for i in 1..constants.len() {\n        t = h + k + constants[i];\n        h = t.pow_32(exp);\n    }\n    h + k\n}\n\nglobal MIMC_BN254_ROUNDS: u32 = 91;\n//generated from seed \"mimc\" using keccak256\nglobal MIMC_BN254_CONSTANTS: [Field; MIMC_BN254_ROUNDS] = [\n    0,\n    20888961410941983456478427210666206549300505294776164667214940546594746570981,\n    15265126113435022738560151911929040668591755459209400716467504685752745317193,\n    8334177627492981984476504167502758309043212251641796197711684499645635709656,\n    1374324219480165500871639364801692115397519265181803854177629327624133579404,\n    11442588683664344394633565859260176446561886575962616332903193988751292992472,\n    2558901189096558760448896669327086721003508630712968559048179091037845349145,\n    11189978595292752354820141775598510151189959177917284797737745690127318076389,\n    3262966573163560839685415914157855077211340576201936620532175028036746741754,\n    17029914891543225301403832095880481731551830725367286980611178737703889171730,\n    4614037031668406927330683909387957156531244689520944789503628527855167665518,\n    19647356996769918391113967168615123299113119185942498194367262335168397100658,\n    5040699236106090655289931820723926657076483236860546282406111821875672148900,\n    2632385916954580941368956176626336146806721642583847728103570779270161510514,\n    17691411851977575435597871505860208507285462834710151833948561098560743654671,\n    11482807709115676646560379017491661435505951727793345550942389701970904563183,\n    8360838254132998143349158726141014535383109403565779450210746881879715734773,\n    12663821244032248511491386323242575231591777785787269938928497649288048289525,\n    3067001377342968891237590775929219083706800062321980129409398033259904188058,\n    8536471869378957766675292398190944925664113548202769136103887479787957959589,\n    19825444354178182240559170937204690272111734703605805530888940813160705385792,\n    16703465144013840124940690347975638755097486902749048533167980887413919317592,\n    13061236261277650370863439564453267964462486225679643020432589226741411380501,\n    10864774797625152707517901967943775867717907803542223029967000416969007792571,\n    10035653564014594269791753415727486340557376923045841607746250017541686319774,\n    3446968588058668564420958894889124905706353937375068998436129414772610003289,\n    4653317306466493184743870159523234588955994456998076243468148492375236846006,\n    8486711143589723036499933521576871883500223198263343024003617825616410932026,\n    250710584458582618659378487568129931785810765264752039738223488321597070280,\n    2104159799604932521291371026105311735948154964200596636974609406977292675173,\n    16313562605837709339799839901240652934758303521543693857533755376563489378839,\n    6032365105133504724925793806318578936233045029919447519826248813478479197288,\n    14025118133847866722315446277964222215118620050302054655768867040006542798474,\n    7400123822125662712777833064081316757896757785777291653271747396958201309118,\n    1744432620323851751204287974553233986555641872755053103823939564833813704825,\n    8316378125659383262515151597439205374263247719876250938893842106722210729522,\n    6739722627047123650704294650168547689199576889424317598327664349670094847386,\n    21211457866117465531949733809706514799713333930924902519246949506964470524162,\n    13718112532745211817410303291774369209520657938741992779396229864894885156527,\n    5264534817993325015357427094323255342713527811596856940387954546330728068658,\n    18884137497114307927425084003812022333609937761793387700010402412840002189451,\n    5148596049900083984813839872929010525572543381981952060869301611018636120248,\n    19799686398774806587970184652860783461860993790013219899147141137827718662674,\n    19240878651604412704364448729659032944342952609050243268894572835672205984837,\n    10546185249390392695582524554167530669949955276893453512788278945742408153192,\n    5507959600969845538113649209272736011390582494851145043668969080335346810411,\n    18177751737739153338153217698774510185696788019377850245260475034576050820091,\n    19603444733183990109492724100282114612026332366576932662794133334264283907557,\n    10548274686824425401349248282213580046351514091431715597441736281987273193140,\n    1823201861560942974198127384034483127920205835821334101215923769688644479957,\n    11867589662193422187545516240823411225342068709600734253659804646934346124945,\n    18718569356736340558616379408444812528964066420519677106145092918482774343613,\n    10530777752259630125564678480897857853807637120039176813174150229243735996839,\n    20486583726592018813337145844457018474256372770211860618687961310422228379031,\n    12690713110714036569415168795200156516217175005650145422920562694422306200486,\n    17386427286863519095301372413760745749282643730629659997153085139065756667205,\n    2216432659854733047132347621569505613620980842043977268828076165669557467682,\n    6309765381643925252238633914530877025934201680691496500372265330505506717193,\n    20806323192073945401862788605803131761175139076694468214027227878952047793390,\n    4037040458505567977365391535756875199663510397600316887746139396052445718861,\n    19948974083684238245321361840704327952464170097132407924861169241740046562673,\n    845322671528508199439318170916419179535949348988022948153107378280175750024,\n    16222384601744433420585982239113457177459602187868460608565289920306145389382,\n    10232118865851112229330353999139005145127746617219324244541194256766741433339,\n    6699067738555349409504843460654299019000594109597429103342076743347235369120,\n    6220784880752427143725783746407285094967584864656399181815603544365010379208,\n    6129250029437675212264306655559561251995722990149771051304736001195288083309,\n    10773245783118750721454994239248013870822765715268323522295722350908043393604,\n    4490242021765793917495398271905043433053432245571325177153467194570741607167,\n    19596995117319480189066041930051006586888908165330319666010398892494684778526,\n    837850695495734270707668553360118467905109360511302468085569220634750561083,\n    11803922811376367215191737026157445294481406304781326649717082177394185903907,\n    10201298324909697255105265958780781450978049256931478989759448189112393506592,\n    13564695482314888817576351063608519127702411536552857463682060761575100923924,\n    9262808208636973454201420823766139682381973240743541030659775288508921362724,\n    173271062536305557219323722062711383294158572562695717740068656098441040230,\n    18120430890549410286417591505529104700901943324772175772035648111937818237369,\n    20484495168135072493552514219686101965206843697794133766912991150184337935627,\n    19155651295705203459475805213866664350848604323501251939850063308319753686505,\n    11971299749478202793661982361798418342615500543489781306376058267926437157297,\n    18285310723116790056148596536349375622245669010373674803854111592441823052978,\n    7069216248902547653615508023941692395371990416048967468982099270925308100727,\n    6465151453746412132599596984628739550147379072443683076388208843341824127379,\n    16143532858389170960690347742477978826830511669766530042104134302796355145785,\n    19362583304414853660976404410208489566967618125972377176980367224623492419647,\n    1702213613534733786921602839210290505213503664731919006932367875629005980493,\n    10781825404476535814285389902565833897646945212027592373510689209734812292327,\n    4212716923652881254737947578600828255798948993302968210248673545442808456151,\n    7594017890037021425366623750593200398174488805473151513558919864633711506220,\n    18979889247746272055963929241596362599320706910852082477600815822482192194401,\n    13602139229813231349386885113156901793661719180900395818909719758150455500533,\n];\n\n//mimc implementation with hardcoded parameters for BN254 curve.\n#[field(bn254)]\n#[deprecated]\npub fn mimc_bn254<let N: u32>(array: [Field; N]) -> Field {\n    let exponent = 7;\n    let mut r = 0;\n    for elem in array {\n        let h = mimc(elem, r, MIMC_BN254_CONSTANTS, exponent);\n        r = r + elem + h;\n    }\n    r\n}\n\npub struct MimcHasher {\n    _state: [Field],\n}\n\nimpl Hasher for MimcHasher {\n    #[field(bn254)]\n    fn finish(self) -> Field {\n        let exponent = 7;\n        let mut r = 0;\n        for i in 0..self._state.len() {\n            let h = mimc(self._state[i], r, MIMC_BN254_CONSTANTS, exponent);\n            r = r + self._state[i] + h;\n        }\n        r\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for MimcHasher {\n    fn default() -> Self {\n        MimcHasher { _state: &[] }\n    }\n}\n","path":"std/hash/mimc.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"39":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<let N: u32>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let index_bits: [u1; N] = index.to_le_bits();\n    let mut current = leaf;\n    for i in 0..N {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"70":{"source":"use dep::std;\nuse dep::ecrecover;\n\nfn main(\n    // Token Balance\n    address: Field,\n    balance: Field,\n    // Merkle Membership\n    note_root: pub Field,\n    index: Field,\n    note_hash_path: [Field; 13],\n    // Signature\n    signature: [u8; 64],\n    message_hash: [u8; 32],\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    // Token Data\n    token_address: pub Field,\n    timestamp: pub u64,\n    // Hash\n    hash: pub Field,\n) -> pub (u64, Field, Field) {\n    let recovered_address = ecrecover::ecrecover(pub_key_x, pub_key_y, signature, message_hash);\n    assert(address == recovered_address);\n\n    let commitment = std::hash::mimc::mimc_bn254([address, balance]);\n\n    // Check that the input note commitment is in the root\n    let new_root = std::merkle::compute_merkle_root(commitment, index, note_hash_path);\n    assert(new_root == note_root);\n\n    (timestamp, hash, token_address)\n}\n","path":"/Users/kartik/2024/anon/packages/circuits/submit-hash/src/main.nr"},"71":{"source":"use dep::std;\n \nmod secp256k1;\n\npub fn ecrecover(\n    pub_key_x: [u8; 32],\n    pub_key_y: [u8; 32],\n    signature: [u8; 64], // clip v value\n    hashed_message: [u8; 32]\n) -> Field {\n    let key = secp256k1::PubKey::from_xy(pub_key_x, pub_key_y);\n\n    assert(key.verify_sig(signature, hashed_message));\n    let addr = key.to_eth_address();\n\n    addr\n}\n\n#[test]\nfn test_ecrecover() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let addr = ecrecover(pub_key_x, pub_key_y, signature, hashed_message);\n    assert(addr == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/kartik/nargo/github.com/signorecello/ecrecover-noirmain/src/lib.nr"},"72":{"source":"use dep::std;\n\nuse dep::array_helpers;\n\nstruct PubKey {\n    pub_x: [u8; 32],\n    pub_y: [u8; 32],\n}\n\nfn split_uncompressed_pub_key(\n    pub_key: [u8; 65]\n) -> ([u8; 32], [u8; 32]) {\n    let mut pub_key_x: [u8; 32] = [0; 32];\n    let mut pub_key_y: [u8; 32] = [0; 32];\n\n    for i in 0..32 {\n        pub_key_x[i] = pub_key[i + 1];\n        pub_key_y[i] = pub_key[i + 32 + 1];\n    };\n\n    (pub_key_x, pub_key_y)\n}\n\nimpl PubKey {\n    pub fn from_xy(pub_x: [u8; 32], pub_y: [u8; 32]) -> PubKey {\n        PubKey {\n            pub_x,\n            pub_y,\n        }\n    }\n\n    pub fn from_unified(pub_key: [u8; 64]) -> PubKey {\n        let (key_x, key_y) = array_helpers::split_u8_64(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn from_uncompressed(pub_key: [u8; 65]) -> PubKey {\n        assert(pub_key[0] == 0x04);\n        let (key_x, key_y) = split_uncompressed_pub_key(pub_key);\n\n        PubKey {\n            pub_x: key_x,\n            pub_y: key_y,\n        }\n    }\n\n    fn verify_sig(self, signature: [u8; 64], hashed_message: [u8; 32]) -> bool {\n        std::ecdsa_secp256k1::verify_signature(self.pub_x, self.pub_y, signature, hashed_message)\n    }\n\n    fn to_eth_address(self) -> Field {\n        let pub_key = array_helpers::u8_32_to_u8_64(self.pub_x, self.pub_y);\n        let hashed_pub_key = std::hash::keccak256(pub_key, 64);\n\n        let mut addr: Field = 0;\n        for i in 0..20 {\n            // shift left by 8 and add the new value\n            addr = (addr * 256) + hashed_pub_key[i + 12] as Field;\n        }\n\n        addr\n    }\n\n    fn ecrecover(\n        self,\n        signature: [u8; 64],\n        hashed_message: [u8; 32]\n    ) -> Field {\n        assert(self.verify_sig(signature, hashed_message));\n\n        self.to_eth_address()\n    }\n}\n\n\n#[test]\nfn test_ecrecover_via_key() {\n    let pub_key_x = [131, 24, 83, 91, 84, 16, 93, 74, 122, 174, 96, 192, 143, 196, 95, 150, 135, 24, 27, 79, 223, 198, 37, 189, 26, 117, 63, 167, 57, 127, 237, 117];\n    let pub_key_y = [53, 71, 241, 28, 168, 105, 102, 70, 242, 243, 172, 176, 142, 49, 1, 106, 250, 194, 62, 99, 12, 93, 17, 245, 159, 97, 254, 245, 123, 13, 42, 165];\n    let signature = [57, 17, 112, 239, 241, 30, 64, 157, 170, 50, 85, 145, 156, 69, 226, 85, 147, 164, 10, 82, 71, 93, 42, 132, 200, 220, 161, 255, 95, 241, 211, 141, 81, 7, 150, 25, 25, 27, 162, 213, 80, 61, 12, 170, 50, 4, 154, 203, 252, 229, 119, 29, 202, 153, 50, 25, 126, 145, 245, 23, 136, 75, 29, 177];\n    let hashed_message = [13, 82, 120, 60, 76, 186, 215, 235, 175, 126, 185, 67, 252, 100, 143, 82, 130, 165, 32, 112, 68, 47, 193, 141, 141, 209, 109, 219, 47, 203, 175, 102];\n\n    let key = PubKey::from_xy(pub_key_x, pub_key_y);\n    assert(key.ecrecover(signature, hashed_message) == 0xf39fd6e51aad88f6f4ce6ab8827279cfffb92266);\n}\n","path":"/Users/kartik/nargo/github.com/signorecello/ecrecover-noirmain/src/secp256k1.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}